# 일래스틱서치 시작하기

## 핵심개념
JSON 도큐먼트를 일급 객체로 취급하고 이를 다양한 연산에 사용할 수 있습니다. 이 JSON 도큐먼트는 여러 타입과 인덱스로 구성되기도 한다. 일래스틱서치의 핵심 추상화 개념인 아래 개념을 살펴봅시다.
- 인덱스
- 타입
- 도큐먼트
- 클러스터
- 노드
- 샤드 및 복제본
- 매핑 및 타입
- 역색인

_example_

catalog 는 인덱스, product 는 타입, 1인 인덱스 생성 후 도큐먼트에 할당되는 ID 를 나타낸다.

```
curl -XPUT http://localhost:9200/catalog/product/1 -H 'Content-Type: application/json'
-d '{ "sku" : "SP000001",
 "title" : "Elasticsearch for Hadoop",
 "description": "Elasticsearch for Hadoop",
 "author": "Vishal Shukla",
 "ISBN": "1785288997",
 "price": 26.99
 }'
```


1. 인덱스

  인덱스는 일래스틱서치에서 단일 타입의 도큐먼트를 저장하고 관리하는 논리하는 컨테이너. 인덱스는 여러개의 단일 타입 도큐먼트를 가질 수 있습니다. (인덱스 ⊃ 타입 ⊃ 도큐먼트s)
  - RDB 와의 비교

    비슷 : 인덱스 개념은 RDB 의 스키마와 거의 유사하고 타입은 테이블, 도큐먼트는 테이블의 레코드로 비유될 수 있음

    다름 : 일래스틱서치는 단일 인덱스와 단일 타입만 가질 수 있음 (일래스틱서치 6.0부터)

2. 타입

  위의 예제에서 catalog 인덱스에 색인된 타입은 product 였습니다. product 에 저장된 도큐먼트는 하나의 product 를 나타내고 타입은 논리적으로 인덱스 내의 같은 도큐먼트 종류를 그룹화하고 구성하는데 유용합니다. 일반적으로 공통 필드 집합을 가진 도큐먼트는 단일 타입으로 그룹화 합니다. 물론 도큐먼트 내에 어떠한 필드도 저장할 수 있지만 완전히 다른 도큐먼트라면 다른 인덱스에 별도의 타입으로 저장하는 것을 권장함

3. 도큐먼트

  일래스틱서치내의 일급객채, 다중필드로 구성된 도큐먼트는 일래스틱서치에서 정보의 기본 단위입니다. 일래스틱서치에서 도큐먼트는 사용자가 정의한 필드 외에도 다음과 같이 내부적으로 메타 필드를 가지고 있습니다.

  - _id" : 도큐먼트의 고유 식별자, 자동생성되거나 사용자가 정의할 수 있습니다.
  - _type : 도큐먼트의 타입 이름
  - _index : 도큐먼트의 인덱스 이름


4. 노드

  일래스틱 서치는 분산 시스템입니다. 네트워크에 위치한 각 시스템에서 실행되고, 다른 프로세스와 통신하는 다중 프로세스로 구성됩니다. 일반적으로 단일 서버에서 구동되는 일래스틱서치 노드는 클러스터의 부분집합이 될 수 있고 이 노드는 색인, 검색 및 기타 연산 작업을 수행합니다. 또한 모든 노드는 고유 ID 와 이름을 가집니다. (elasticsearch.yml 에서 지정할 수도 있음)
> 노드는 가장 낮은 레벨의 일래스틱서치의 단일 인스턴스로 데이터 공유를 담당합니다.


5. 클러스터

  클러스터는 하나 이상의 노드로 구성됩니다. 모든 노드는 항상 클러스터의 부분집합이고 단일 노드 클러스터라고 해도 클러스터의 일부라고 볼 수 있습니다. elasticsearch.yml 에서 클러스터 이름을 변경하지 않고 같은 네트워크에서 여러 노드를 시작하면 클러스터가 자동으로 구성됩니다. (default name : elasticsearch)
> 의도치 않은 클러스터 구성이 시작될 수 있으므로 클러스터 이름을 변경하는 것을 권장합니다. 단일 클러스터는 하나 이상의 인덱스를 호스팅할 수 있습니다.


6. 샤드 및 복제본

  *샤드*는 클러스터에서 인덱스를 분배하고 단일 인덱스의 도큐먼트를 여러 노드로 분할하는데 사용합니다. 단일 노드에 저장할 수 있는 데이터양에 한게가 있으므로 (저장소, 메모리, 처리용량 등) 샤드를 활용하면 단일 인덱스 데이터를 분할해 클러스터의 저장소와 메모리, 처리용량을 적절히 활용할 수 있습니다.
샤딩은 일래스틱서치에 내장된 고유 기능이며 아래와 같이 확장 및 병렬화 기능을 담당합니다. (데이터를 분할하는 과정은 샤딩)

  - 클러스터에 위치한 여러 노드의 저장소 활용
  - 클러스터에 위치한 여러 노드의 처리 능력 활용

  기본적으로 모든 인덱스는 일래스틱서치에서 5개의 샤드를 갖도록 구성됩니다. 인덱스 생성시점에 샤드 갯수를 지정할 수 있고 인덱스를 생성하고 나면 샤드를 변경할 수는 없습니다.

  *복제본* 은 일래스틱서치같은 분산 시스템에서 하드웨어 장애 상황에서 문제없이 실행되어야 하는 고가용성 조건을 부합하기 위한 장치입니다. 3개의 노드가 5개의 샤드를 적절하게 분산해서 가지고 있을 때 하나의 노드가 장애상황이더라도 다른 노드에서 데이터를 읽을 수 있도록 샤드의 복제본이 다른 노드에 적절하게 분산됩니다. 또한 복제본에서 쿼리 작업이 이루어 질 수 있습니다. 검색, 쿼리, 집계와 같은 읽기 연산은 복제본에서 실행될 수 있습니다. 일래스틱서치에서 노드 전반에 걸쳐 정직하게 분배하여 쿼리실행을 처리합니다.


7. 매핑 및 타입

  일래스틱서치는 스키마가 존재하지 않습니다. 하지만 실제 운영환경에서 사용하는 데이터는 스키마가 존재하고 체계화된 구조를 갖기 때문에 특정 타입으로 지정된 도큐먼트는 항상 공통 필드 집합을 갖습니다. 해서 실제로 인덱스 타입은 공통 필드를 기반으로 생성하는 것이 좋습니다.

  ##### 데이터 타입

  일래스틱서치는 텍스트와 숫자, 참과 거짓, 이진 객체, 배열, 객체, 중첩타입, 지리 및 지형정보, IPv4 및 IPv6 주소같은 특수한 데이터 타입을 저장하기 위해 다양한 데이터 타입을 지원합니다. 도큐먼트에서 각 필드는 데이터 타입을 가지고 있습니다.
    - 핵심 데이터 타입
      1. 문자열(String) 데이터 타입
        - text : 전문 텍스트 검색에 활용
        - keyword : 정렬, 필터링, 집계 기능 지원
      2. 숫자(Numeric) 데이터 타입
        - byte, short, integer, long : 각각 8bit, 16bit, 32bit, 64bit 정밀도를 가진 부호있는 정수값
        - float, double : 단일 정밀도(32bit), 이중 정밀도(64bit) 표현이 가능한 IEEE 754 부동 소수점 수
        - half_float : 반정밀도(16bit) 를 표현하는 IEEE 754 부동 소수점 수
        - scaled_float : 길고 고정된 비율을 기반으로 한 부동 소수점 수
      3. 날짜(Date) 데이터 타입
        - date : 밀리초 단위로 타임스탬프를 저장할 수 있는 데이터 타입
      4. 논리(Boolean) 데이터 타입
        - boolean : 참 vs 거짓
      5. 이진(Binary) 데이터 타입
        - binary : Base64 인코딩을 수행한 후, 임의의 이진값을 저장할 수 있는 데이터 타입
      6. 범위(Range) 데이터 타입
        - integer_range, float_range, long_range, double_range, date_range : 정수, 실수 등의 다양한 범위를 정의하는 데이터 타입
    - 복합 데이터 타입
      1. 배열 데이터 타입 : 문자열, 정수 등 같은 타입을 가진 인스턴스 배열, 다른 타입을 혼용해서 쓸 수는 없다
      2. 객체 데이터 타입 : JSON 도큐먼트 안에 내부 객체가 위치할 수 있다
      3. 중첩 데이터 타입 : 내부 객체의 배열을 지원하는데 유용, 각 내부 객체는 독립적으로 쿼리 가능해야 한다
    - 기타
      1. 지리(Geo-Point) 데이터 타입 : 경도와 위도 저장, 특정 지점에서 2Km 내 위치한 모든 ATM 등을 검색할 수 있다
      2. 지형(Geo-Shape) 데이터 타입 : 다각형, 지도등 기하학 지형을 저장, 특정 지형 내 모든 항목을 검색할 수 있다.
      3. IP 데이터 타입 : IP 주소 저장에 이용

  ##### 매핑

  예를들어 catalog 인덱스에 product 타입이라는 도큐먼트를 추가하는 경우 일래스틱서치는 아래와 같은 작업을 수행합니다.
    - catalog 인덱스 생성 : 일래스틱서치에는 인덱스의 각종 연산을 처리하는 인덱스 API 가 있고 인덱스 생성, 삭제, 조회, 매핑생성등 여러가지 고급작업을 할 수 있습니다. (more:https://www.elastic.co/guide/en/elasticsearch/reference/current/indices.html)
    - product 타입에 대한 매핑 정의 : 도큐먼트가 아직 존재하지 않는다면 필드의 데이터 타입을 추정합니다. 모든 필드의 데이터 타입을 추론하고 이러한 기능을 타입의 동적매핑이라고 합니다. 기본적으로 타입 동적 매핑은 일래스틱서치에서 활성화 상태입니다.
    - 매핑확인 : GET /catalog/_mapping/product


  8. 역색인

    일래스틱서치와 전문 텍스트 검색을 지원하는 시스템에서 핵심 데이터 구조입니다. 책의 끝에 나오는 색인 목록과 유사합니다. 도큐먼트에 나타난 용어를 도큐먼트에 매핑하는 방식으로 사용합니다.
    - 역색인 용어는 구두점을 제거하고 수문자로 치환한 후 분리된 글자
    - 용어는 알파펫순으로 정렬

    역색인은 정렬이 이미 되어 있기 때문에 빠르고 이미 분류되어 있으므로 검색에 매우 용이하며 검색을 빠르게 하기 위한 기본 요소입니다. 기본적으로 일래스틱서치는 도큐먼트의 모든 필드에 역색인을 작성하고, 필드가 나타난 일래스틱서치 도큐먼트를 가리키도록 만듭니다.


## CRUD 연산

#### 색인 API
- ID를 지정해 도큐먼트 색인하기
> PUT /catalog/product/1 {data}
- ID를 제공하지 않고 도큐먼트 색인하기 : 해시 문자열로 자동생성된다
> PUT /catalog/product {data}

#### 조회 API
GET /{index}/{type}/{id} (메타정보도 같이 조회됨)
> GET /catalog/product/1

#### 업데이트 API
POST /{index}/{type}/{id}/_update
> POST /catalog/product/1/_update { "doc": { "price" : "28.99" } }

응답
```
{
  "_index": "catalog",
  "_type": "product",
  "_id": "1",
  "_version": 5,
  "result": "updated",
  "_shards": {
  "total": 2,
  "successful": 1,
  "failed": 0
  },
  "_seq_no": 4,
  "_primary_term": 1
}
```

"doc" 요소 하위에 지정된 속성은 기존 도큐먼트에 병합됩니다. 업데이트 요청된 필드만 변경되고 다른 필드는 변경되지 않습니다. 일래스틱서치는 내부적으로 각 도큐먼트의 버전(_version)을 관리하는데 도큐먼트가 변경될 때마다 버전 번호는 증가한다. 위 업데이트 API 는 도큐먼트가 존재할 때만 동작하고 도큐먼트가 없는 경우 오류를 반환합니다.

*doc_as_upsert* 옵션
> POST /catalog/product/3/_update { "doc": { "title": "Elasticsearch 5.0 Cookbook", "price" : "54.99" }, "doc_as_upsert" : true }

응답
```
{
  "_index": "catalog",
  "_type": "product",
  "_id": "3",
  "_version": 1,
  "result": "created",
  "_shards": {
  "total": 2,
  "successful": 1,
  "failed": 0
  },
  "_seq_no": 0,
  "_primary_term": 1
}
```

#### 삭제 API
DELETE /{index}/{type}/{id}

> DELETE /catalog/product/3

응답
```
{
  "_index": "catalog",
  "_type": "product",
  "_id": "3",
  "_version": 2,
  "result": "deleted",
  "_shards": {
  "total": 2,
  "successful": 1,
  "failed": 0
  },
  "_seq_no": 1,
  "_primary_term": 1
  }
```

RDB 가 CRUD 연산에 적합한 B-트리를 만들고 관리하는 것과 달리, 일래스틱서치는 아파치 루씬 기능을 사용해 역색인이라는 완전히 다른 데이터 구조로 데이터를 관리한다는 점을 명십합시다.


## 인덱스 생성 및 매핑 관리

지금까지 인덱스 및 매핑 자동생성을 살펴보았다면 이제는 직접 제어하는 방법을 알아봅시다.
  - 인덱스 생성
  - 기존 인덱스에 타입 매핑 생성
  - 매핑 업데이트

1. 인덱스 생성 (p.82)
```
PUT /catalog
  {
      "settings" : {
        "index" : {
          "number_of_shards" : 5,
          "number_of_replicas" : 2
        }
      },
      "mappings" : {
        "my_type" : {
          "properties" : {
            "f1" : {
              "type" : "text"
            },
            "f2" : {
              "type" : "keyword"
            }
          }
        }
      }
  }
```
= 5개의 샤드와 2개의 복제본을 갖는 catalog 인덱스 + 텍스트와 키워드 타입으로 정의된 2개의 필드를 가진 my_type 이라는 타입정의


2. 기존 인덱스에 타입 매핑 생성
```
PUT /catalog/_mapping/category
  {
    "properties" : {
      "name" : {
        "type" : "text"
      }
    }
  }
```
= 이미 존재하는 인덱스에 텍스트 데이터 타입을 가지는 name 이라는 필드를 가지는 category 라는 타입 생성

  category 타입에 데이터 타입이 지정되지 않은 필드인 description 이 추가된다고 가정해 봅시다. 이 때 사전 매핑작업이 없으면 description 은 처음에 색인된 데이터로 추론되어 매핑됩니다. 필드 타입은 해당 필드 내에서 하나 이상의 도큐먼트가 색인된 후에는 변경될 수 없으므로 타입을 제어하려면 첫 번째 도큐먼트를 색인하기 전에 필드에 대한 매핑을 정의해야 합니다.

3. 매핑 업데이트
```
PUT /catalog/_mapping/category
  {
    "properties" : {
      "code`" : {
        "type" : "keyword"
      }
    }
  }
```
기존에 있던 category 타입의 매핑으로 병합됩니다.


## REST API 개요

공통 API 규칙
  - JSON 응답형식
  - 다중 인덱스 처리

모든 도큐먼트 검색 (default limit : 10)
> GET /_search

단일 인덱스에서 모든 도큐먼트 검색 (타입도 같이 지정 가능)
> GET /catalog/_search

> GET /catalog/product/_search


다중 인덱스에서 모든 도큐먼트 검색

> GET /catalog,my_index/_search

모든 인덱스에서 특정 타입의 모든 도큐먼트 검색

> GET /_all/product/_search
