
## 하드웨어와 운영체제

개요
하드웨어가 발전하고 복잡해짐에 따라 소프트웨어도 점점 더 복잡해 지고 있습니다.
이 가운데 자바는 하드웨어 향상에 따른 혜택을 많이 받은 언어입니다. 언어 및 런타임 설계가 프로세서가 강력해 지는 시류와 잘 맞아 떨어졌습니다.
그래도 성능을 고민하는 개발자라면 자바 플랫폼의 근간 원리와 기술을 잘 알아 둬야 합니다.

```
뒷장에서 살펴볼 내용
- 플랫폼 및 코드 수준에서 최적화 하는 기법
- 최신 JVM의 소프트웨어 아키텍쳐
```


#### 하드웨어
##### 메모리
하드웨어 성능이 좋아지면서 갯수가 급증한 트랜지스터는 클록 속도를 증가하게 했고 초당 더 많은 명령어를 처리할 수 있게 되면서 더 많은 연산을 할 수 있게 되었지만 메모리가 받쳐주지 못하는 문제가 발생했습니다.
(그림 3-1, page 65)

> CPU 와 메모리는 실제로 엄청나게 많은 트랜지스터로 구성된 전자 부품입니다.
CPU 내부는 레지스터, 제어장치, 연산장치, 클록 등 4대 요소로 구성되어 있습니다.
여기서 레지스터란 처리하는 명령어와 데이터를 보관하는 영역으로 일종의 메모리와 같은 것입니다.

> 클록 신호(속도)는 컴퓨터가 작동하는 시간을 계산하는데 클록 펄스라고도 하며 주파수가 클 수록 대개 CPU는 빠른 속도로 작동하게 됩니다.


*해결방안*
###### 메모리캐시(=CPU캐시)
CPU 에 있는 메모리 영역으로 레지스터보다는 느리지만 메인 메모리보다는 훨씬 빠릅니다. 자주 사용되는 메모리 위치는 CPU 가 CPU캐시에 보관하게 됩니다. 액세스 빈도가 높은 캐시일 수록 코어와 가까이 위치하는 방식으로 여러 계층이 있습니다.
(그림 3-2, page 66)
  - 전용 프라이빗 캐시 L1, L2
  - 일부 또는 전체 코어가 공유하는 L3

##### 캐시 일관성 프로토콜
메모리캐시를 도입하므로써 CPU와 메모리간의 갭으로 인한 처리율은 현저히 개선되었지만 데이터 일관성 문제가 발생하였습니다. 해서 *캐시 일관성 프로토콜* 을 도입하여 해결하고 있습니다.
  - 대표적인 프로토콜 : MESI protocol
  - 캐시를 위한 두가지 방식
    - write-through : 캐시 갱신 때마다 연산 결과를 메모리에 저장 - 효율 낮음
    - write-back : 캐시 라인이 캐시로부터 제거될 때만 갱신
  - 캐시기술 덕분에 메모리 대역폭 측면에서 효과를 볼 수 있습니다.
    - DDR RAM 을 이용하면 이론적으로 최대 8~12G 쓰기 속도가 나옵니다.
    - 캐시 하드웨어 작동원리 예제 살펴보기 (page 70)

##### 최신 프로세서의 특징
  - 변환 색인 버퍼(TLB) - 가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블의 캐시 역할을 하고 덕분에 가상 주소를 참조해 물리 주소에 액세스하는 작업 속도가 매우 빨라집니다.
  - 분기 예측과 추측 실행 - 분기 실행 시 가장 발생 가능성이 큰 명령을 실행합니다. 운 좋게 추측이 맞아 떨어지면 CPU 는 다음 작업을 진행하고 틀리면 부분적으로 실행한 명령을 모두 폐기한 후 다시 올바른 명령을 실행합니다.
  ###### 2018년 초반 아주 많은 CPU 에 영향을 끼친 주요 보안 문제의 근원입니다.
  - 하드웨어 메모리 모델
    - 여러 CPU가 일관되게 동일한 메모리 주소를 액세스하기 위한 노력 - 코드 실행 순서를 바꾼다
    - JMM - 프로세서 타입별로 상이한 메모리 액세스 일관성을 고려하여 weak model로 설계
      - http://preshing.com/20120930/weak-vs-strong-memory-models/
      - 멀티스레드 코드가 제대로 동작하려면 lock & volatile 주의해서 정확히 알고 사용

##### 운영체제
- 여러 실행 프로세스가 공유하는 리소스 액세스를 관장하는 역할을 합니다.
- *메모리 관리 유닛 (MMU)* 를 통한 가상 주소 방식과 페이지 테이블은 메모리 액세스 제어의 핵심으로 한 프로세스가 소유한 메모리 영역을 다른 프로세스가 함부로 훼손하지 못하게 합니다.
- 스케쥴러 둘러보기 (그림 3-6, page 76)
- 시간문제 - 각각 OS 가 제공하는 네이티브 메서드의 구현방식이 달라서 OS 별 시간측정이 달라질 수 있습니다.
- 컨텍스트교환 - 앞서 스케쥴러와 연관, 왜냐하면 모드가 바뀌면 명령어와 다른 캐시들을 어쩔 수 없이 비워야 하게 되므로 유저모드에서 커널모드로 변경될 때에는 더욱 비싼 작업이 됩니다. (그림3-7, page 79)
  - 이에 대한 방안으로 가상 동적 공유 객체(vDSO) 제공합니다. - 커널 자료구조를 읽어 시스템 클록 시간을 얻고 이 자료구조를 vDSO로 유저 프로세스의 주소 공간에 매핑시킨다면 커널모드로의 변경이 필요없어져 그만큼 속도가 빠르게 됩니다.

##### 단순 시스템 모델
성능 문제를 일으키는 근원을 알아봅시다. (그림 3-8, page 81)
- 어떤 거라도 성능 문제를 일으킬 수 있다
  - CPU 사용률 : vmstat, iostat > CPU 사용률을 100% 가깝게 유지하는 것이 좋다
  - 가비지 수집 : GC 는 유저 공간의 CPU 사이클을 소비하므로 유저 공간에서 CPU 를 100% 가깝게 사용하고 있다면 GC 를 의심해 봐야 합니다
  - 입출력 : I/O 성능을 위해 커널 바이패스 I/O 를 이용하기도 한다 > 커널을 거치지 않고 유저가 직접 하드웨어에 접근하는 것
  - 기계 공감 : 하드웨어의 한계를 인지하고 대처하는 것

##### 가상화
- 호스트 OS 위에 사본 OS 를 하나의 프로세스로 실행시키는 모양
- 가상화 시스템에서는 사본 OS 가 하드웨어에 직접 액세스할 수 없어서
  - 프리빌리지드 명령어를 언프리빌리지드 명령어로 고쳐서 씁니다.
  - 컨텍스트 교환중 지나친 캐시 플러시가 일어나지 않도록 일부 OS 커널 자료구조를 새도해야 합니다.

##### JVM과 운영체제
- JVM 에서 하부 OS 에 접근할 필요가 있을 때 자바 네이티브 메서드로 구현합니다.
- 이 작업을 대행하는 인터페이스를 JNI, 자바 네이티브 인터페이스라고 합니다. (그림 3-11, page 91)
